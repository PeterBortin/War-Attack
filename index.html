<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
    <title>Procedural Night City</title>
    <style>
        html, body { margin:0; padding:0; overflow:hidden; background:#000; font-family: 'Courier New', monospace; touch-action:none; }
        canvas { display:block }
        #ui { position:fixed; top:10px; left:10px; color:#0ff; font-size:12px; background:rgba(0,0,10,.8); padding:10px; border:1px solid #0ff; border-radius:5px; z-index:10; pointer-events:none; text-shadow: 0 0 5px #0ff; }
        #touch { position:fixed; inset:0; pointer-events:none; }
        .joy { position:absolute; left:30px; bottom:30px; width:100px; height:100px; border-radius:50%; background:rgba(0,255,255,0.05); border:2px solid rgba(0,255,255,0.3); pointer-events:auto; }
        .stick { position:absolute; left:30px; top:30px; width:40px; height:40px; border-radius:50%; background:#0ff; box-shadow: 0 0 15px #0ff; }
        .btn-group { position:absolute; right:30px; bottom:30px; display:flex; flex-direction:column; gap:15px; pointer-events:auto; }
        .btn { width:60px; height:60px; border-radius:50%; background:rgba(0,255,255,0.1); border:2px solid #0ff; color:#0ff; display:flex; align-items:center; justify-content:center; font-size:24px; user-select:none; }
        .btn:active { background: #0ff; color: #000; }
    </style>
</head>
<body>

<div id="ui">
    FPS: <span id="fps">0</span> | Chunks: <span id="chunks">0</span><br>
    XYZ: <span id="pos">0, 0, 0</span>
</div>

<div id="touch">
    <div class="joy" id="joy"><div class="stick" id="stick"></div></div>
    <div class="btn-group">
        <div class="btn" id="up">▲</div>
        <div class="btn" id="down">▼</div>
    </div>
</div>

<canvas id="c"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ===== КОНФИГУРАЦИЯ =====
const CHUNK_SIZE = 60;
const RENDER_DIST = 3;
const clock = new THREE.Clock();

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x020205);
scene.fog = new THREE.FogExp2(0x020205, 0.015);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({
    canvas: document.getElementById('c'), 
    antialias: window.devicePixelRatio < 2 
});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

// ===== СВЕТ И МАТЕРИАЛЫ =====
scene.add(new THREE.AmbientLight(0x4040ff, 0.2));

const flashlight = new THREE.SpotLight(0xffffff, 1.5, 150, Math.PI/4, 0.5, 1);
scene.add(flashlight);
scene.add(flashlight.target);

const createWindowTexture = () => {
    const canvas = document.createElement('canvas');
    canvas.width = 64; canvas.height = 64;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, 64, 64);
    for(let i=0; i<4; i++) {
        for(let j=0; j<4; j++) {
            if(Math.random() > 0.5) {
                ctx.fillStyle = Math.random() > 0.1 ? '#ffcc00' : '#00ffff';
                ctx.fillRect(i*16+4, j*16+4, 8, 8);
            }
        }
    }
    const tex = new THREE.CanvasTexture(canvas);
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    return tex;
};

const winTex = createWindowTexture();

const matGround = new THREE.MeshStandardMaterial({ color: 0x111111 });
const matBuild  = new THREE.MeshStandardMaterial({ 
    color: 0x222222, 
    map: winTex,
    emissive: 0x111111 
});
const matRoof = new THREE.MeshStandardMaterial({
    color: 0x0a0a15,
    roughness: 0.9,
    metalness: 0.3,
    emissive: 0x000814,
    emissiveIntensity: 0.15
});

// ===== ИГРОК =====
const player = {
    pos: new THREE.Vector3(0, 15, 0),
    vel: new THREE.Vector3(),
    rot: new THREE.Euler(0, 0, 0, 'YXZ'),
    speed: 40.0
};

// ===== ЧАНКИ =====
const chunks = new Map();

function createChunk(cx, cz) {
    const group = new THREE.Group();
    const bx = cx * CHUNK_SIZE;
    const bz = cz * CHUNK_SIZE;

    // Земля
    const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE),
        matGround
    );
    ground.rotation.x = -Math.PI / 2;
    ground.position.set(bx + CHUNK_SIZE/2, 0, bz + CHUNK_SIZE/2);
    group.add(ground);

    // Здания
    for(let i = 0; i < 12; i++) {
        const h = 10 + Math.random() * 50;
        const w = 6 + Math.random() * 12;
        const d = 6 + Math.random() * 12;

        // Корпус
        const geo = new THREE.BoxGeometry(w, h, d);
        const uv = geo.attributes.uv;
        for(let j = 0; j < uv.count; j++) {
            uv.setXY(j, uv.getX(j) * (w / 5), uv.getY(j) * (h / 10));
        }

        const body = new THREE.Mesh(geo, matBuild);
        const buildingX = bx + Math.random() * (CHUNK_SIZE - w - 8) + 4;
        const buildingZ = bz + Math.random() * (CHUNK_SIZE - d - 8) + 4;
        body.position.set(buildingX, h/2, buildingZ);

        // Крыша
        const roofGeo = new THREE.BoxGeometry(w * 1.08, 1.4, d * 1.08);
        const roof = new THREE.Mesh(roofGeo, matRoof);
        roof.position.set(buildingX, h + 0.7, buildingZ);

        const building = new THREE.Group();
        building.add(body);
        building.add(roof);

        group.add(building);
    }

    scene.add(group);
    return group;
}

function updateChunks() {
    const pCX = Math.floor(player.pos.x / CHUNK_SIZE);
    const pCZ = Math.floor(player.pos.z / CHUNK_SIZE);

    // Удаляем старые
    for (let [key, group] of chunks) {
        const [cx, cz] = key.split(',').map(Number);
        if (Math.abs(cx - pCX) > RENDER_DIST || Math.abs(cz - pCZ) > RENDER_DIST) {
            scene.remove(group);
            group.children.forEach(c => { 
                if (c.geometry) c.geometry.dispose(); 
                if (c.material) c.material.dispose(); 
            });
            chunks.delete(key);
        }
    }

    // Создаём новые
    for (let x = -RENDER_DIST; x <= RENDER_DIST; x++) {
        for (let z = -RENDER_DIST; z <= RENDER_DIST; z++) {
            const nx = pCX + x, nz = pCZ + z;
            const key = `${nx},${nz}`;
            if (!chunks.has(key)) {
                chunks.set(key, createChunk(nx, nz));
            }
        }
    }
}

// ===== ПРОСТАЯ КОЛЛИЗИЯ =====
function checkCollision(newPos) {
    const playerRadius = 1.4;
    const playerHeight = 1.8;
    const playerFeet = 0.2;

    for (let group of scene.children) {
        if (!(group instanceof THREE.Group)) continue;

        for (let building of group.children) {
            if (!(building instanceof THREE.Group)) continue;

            const body = building.children[0]; // корпус здания
            if (!body || !body.geometry) continue;

            if (!body.geometry.boundingBox) {
                body.geometry.computeBoundingBox();
            }

            const bb = body.geometry.boundingBox.clone();
            bb.applyMatrix4(body.matrixWorld);

            const px = newPos.x;
            const py = newPos.y;
            const pz = newPos.z;

            if (
                px - playerRadius < bb.max.x &&
                px + playerRadius > bb.min.x &&
                pz - playerRadius < bb.max.z &&
                pz + playerRadius > bb.min.z &&
                py - playerHeight < bb.max.y &&
                py + playerFeet > bb.min.y
            ) {
                return true; // столкновение
            }
        }
    }
    return false;
}

// ===== УПРАВЛЕНИЕ (touch) =====
let touchId = null, lastX, lastY;

addEventListener('touchstart', e => {
    if (!e.target.closest('#joy, .btn')) {
        touchId = e.changedTouches[0].identifier;
        lastX = e.changedTouches[0].clientX;
        lastY = e.changedTouches[0].clientY;
    }
});

addEventListener('touchmove', e => {
    for (let t of e.changedTouches) {
        if (t.identifier === touchId) {
            player.rot.y -= (t.clientX - lastX) * 0.005;
            player.rot.x -= (t.clientY - lastY) * 0.005;
            player.rot.x = Math.max(-1.5, Math.min(1.5, player.rot.x));
            lastX = t.clientX;
            lastY = t.clientY;
        }
    }
}, {passive: false});

const joyData = {x:0, y:0};
const stick = document.getElementById('stick');

document.getElementById('joy').ontouchmove = e => {
    e.preventDefault();
    const t = e.touches[0], rect = e.currentTarget.getBoundingClientRect();
    const r = 50;
    let x = t.clientX - rect.left - r, y = t.clientY - rect.top - r;
    const dist = Math.hypot(x, y);
    if (dist > r) { x *= r/dist; y *= r/dist; }
    stick.style.transform = `translate(${x}px, ${y}px)`;
    joyData.x = x / r;
    joyData.y = y / r;
};

document.getElementById('joy').ontouchend = () => {
    joyData.x = 0; joyData.y = 0;
    stick.style.transform = '';
};

let moveUp = 0;
document.getElementById('up').ontouchstart   = () => moveUp =  1;
document.getElementById('up').ontouchend     = () => moveUp =  0;
document.getElementById('down').ontouchstart = () => moveUp = -1;
document.getElementById('down').ontouchend   = () => moveUp =  0;

// ===== ОСНОВНОЙ ЦИКЛ =====
function animate() {
    const dt = clock.getDelta();
    requestAnimationFrame(animate);

    // Направления
    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
    const right   = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
    forward.y = 0; right.y = 0;
    forward.normalize(); right.normalize();

    // Движение
    const moveVec = new THREE.Vector3()
        .addScaledVector(forward, -joyData.y * 1.0)
        .addScaledVector(right,   joyData.x  * 1.0)
        .addScaledVector(new THREE.Vector3(0,1,0), moveUp * 0.8);

    player.vel.lerp(moveVec.multiplyScalar(player.speed), 0.12);

    const wishPos = player.pos.clone().addScaledVector(player.vel, dt);

    // Проверка коллизии
    if (!checkCollision(wishPos)) {
        player.pos.copy(wishPos);
    } else {
        player.vel.multiplyScalar(0.35); // небольшое затухание при ударе о стену
    }

    // Камера и фонарик
    camera.position.copy(player.pos);
    camera.quaternion.setFromEuler(player.rot);

    flashlight.position.copy(player.pos);
    const lookDir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
    flashlight.target.position.copy(player.pos).add(lookDir);

    updateChunks();
    renderer.render(scene, camera);

    // UI
    if (Math.random() > 0.92) {
        document.getElementById('fps').textContent = Math.round(1/dt);
        document.getElementById('chunks').textContent = chunks.size;
        document.getElementById('pos').textContent = 
            `${Math.round(player.pos.x)}, ${Math.round(player.pos.y)}, ${Math.round(player.pos.z)}`;
    }
}

window.onresize = () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
};

animate();
</script>
</body>
</html>