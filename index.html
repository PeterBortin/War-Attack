<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
    <title>Procedural Night City</title>
    <style>
        html, body { margin:0; padding:0; overflow:hidden; background:#000; font-family: 'Courier New', monospace; touch-action:none; }
        canvas { display:block }
        #ui { position:fixed; top:10px; left:10px; color:#0ff; font-size:12px; background:rgba(0,0,10,.8); padding:10px; border:1px solid #0ff; border-radius:5px; z-index:10; pointer-events:none; text-shadow: 0 0 5px #0ff; }
        #touch { position:fixed; inset:0; pointer-events:none; }
        .joy { position:absolute; left:30px; bottom:30px; width:100px; height:100px; border-radius:50%; background:rgba(0,255,255,0.05); border:2px solid rgba(0,255,255,0.3); pointer-events:auto; }
        .stick { position:absolute; left:30px; top:30px; width:40px; height:40px; border-radius:50%; background:#0ff; box-shadow: 0 0 15px #0ff; }
        .btn-group { position:absolute; right:30px; bottom:30px; display:flex; flex-direction:column; gap:15px; pointer-events:auto; }
        .btn { width:60px; height:60px; border-radius:50%; background:rgba(0,255,255,0.1); border:2px solid #0ff; color:#0ff; display:flex; align-items:center; justify-content:center; font-size:24px; user-select:none; }
        .btn:active { background: #0ff; color: #000; }
    </style>
</head>
<body>

<div id="ui">
    FPS: <span id="fps">0</span> | Chunks: <span id="chunks">0</span><br>
    XYZ: <span id="pos">0, 0, 0</span>
</div>

<div id="touch">
    <div class="joy" id="joy"><div class="stick" id="stick"></div></div>
    <div class="btn-group">
        <div class="btn" id="up">▲</div>
        <div class="btn" id="down">▼</div>
    </div>
</div>

<canvas id="c"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
/* ===== КОНФИГУРАЦИЯ ===== */
const CHUNK_SIZE = 60;
const RENDER_DIST = 3; // Радиус прогрузки чанков
const clock = new THREE.Clock();

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x020205);
scene.fog = new THREE.FogExp2(0x020205, 0.015);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({
    canvas: document.getElementById('c'), 
    antialias: window.devicePixelRatio < 2 
});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

/* ===== СВЕТ И ТЕКСТУРЫ ===== */
scene.add(new THREE.AmbientLight(0x4040ff, 0.2));

const flashlight = new THREE.SpotLight(0xffffff, 1.5, 150, Math.PI/4, 0.5, 1);
scene.add(flashlight);
scene.add(flashlight.target);

// Создание текстуры окон
const createWindowTexture = () => {
    const canvas = document.createElement('canvas');
    canvas.width = 64; canvas.height = 64;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, 64, 64);
    for(let i=0; i<4; i++) {
        for(let j=0; j<4; j++) {
            if(Math.random() > 0.5) {
                ctx.fillStyle = Math.random() > 0.1 ? '#ffcc00' : '#00ffff';
                ctx.fillRect(i*16+4, j*16+4, 8, 8);
            }
        }
    }
    const tex = new THREE.CanvasTexture(canvas);
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    return tex;
};

const winTex = createWindowTexture();
const matGround = new THREE.MeshStandardMaterial({ color: 0x111111 });
const matBuild = new THREE.MeshStandardMaterial({ 
    color: 0x222222, 
    map: winTex,
    emissive: 0x111111 
});

/* ===== ИГРОК ===== */
const player = {
    pos: new THREE.Vector3(0, 15, 0),
    vel: new THREE.Vector3(),
    rot: new THREE.Euler(0, 0, 0, 'YXZ'),
    speed: 40.0
};

/* ===== ГЕНЕРАЦИЯ МИРА ===== */
const chunks = new Map();

function createChunk(cx, cz) {
    const group = new THREE.Group();
    const bx = cx * CHUNK_SIZE;
    const bz = cz * CHUNK_SIZE;

    // Земля
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE), matGround);
    ground.rotation.x = -Math.PI / 2;
    ground.position.set(bx + CHUNK_SIZE/2, 0, bz + CHUNK_SIZE/2);
    group.add(ground);

    // Здания
    for(let i=0; i<12; i++) {
        const h = 10 + Math.random() * 50;
        const w = 5 + Math.random() * 10;
        const geo = new THREE.BoxGeometry(w, h, w);
        // Смещаем UV, чтобы окна не растягивались
        const uv = geo.attributes.uv;
        for(let j=0; j<uv.count; j++) {
            uv.setXY(j, uv.getX(j) * (w/5), uv.getY(j) * (h/10));
        }

        const b = new THREE.Mesh(geo, matBuild);
        b.position.set(bx + Math.random() * CHUNK_SIZE, h/2, bz + Math.random() * CHUNK_SIZE);
        group.add(b);
    }

    scene.add(group);
    return group;
}

function updateChunks() {
    const pCX = Math.floor(player.pos.x / CHUNK_SIZE);
    const pCZ = Math.floor(player.pos.z / CHUNK_SIZE);

    // Удаление далеких
    for (let [key, group] of chunks) {
        const [cx, cz] = key.split(',').map(Number);
        if (Math.abs(cx - pCX) > RENDER_DIST || Math.abs(cz - pCZ) > RENDER_DIST) {
            scene.remove(group);
            group.children.forEach(c => { if(c.geometry) c.geometry.dispose(); });
            chunks.delete(key);
        }
    }

    // Создание новых
    for (let x = -RENDER_DIST; x <= RENDER_DIST; x++) {
        for (let z = -RENDER_DIST; z <= RENDER_DIST; z++) {
            const nx = pCX + x, nz = pCZ + z;
            const key = `${nx},${nz}`;
            if (!chunks.has(key)) chunks.set(key, createChunk(nx, nz));
        }
    }
}

/* ===== УПРАВЛЕНИЕ ===== */
let touchId = null, lastX, lastY;
addEventListener('touchstart', e => {
    if (!e.target.closest('#joy, .btn')) {
        touchId = e.changedTouches[0].identifier;
        lastX = e.changedTouches[0].clientX;
        lastY = e.changedTouches[0].clientY;
    }
});

addEventListener('touchmove', e => {
    for (let t of e.changedTouches) {
        if (t.identifier === touchId) {
            player.rot.y -= (t.clientX - lastX) * 0.005;
            player.rot.x -= (t.clientY - lastY) * 0.005;
            player.rot.x = Math.max(-1.5, Math.min(1.5, player.rot.x));
            lastX = t.clientX; lastY = t.clientY;
        }
    }
}, {passive: false});

const joyData = {x:0, y:0};
const stick = document.getElementById('stick');
document.getElementById('joy').ontouchmove = e => {
    const t = e.touches[0], rect = e.currentTarget.getBoundingClientRect();
    const r = 50;
    let x = t.clientX - rect.left - r, y = t.clientY - rect.top - r;
    const d = Math.hypot(x, y);
    if(d > r) { x *= r/d; y *= r/d; }
    stick.style.transform = `translate(${x}px,${y}px)`;
    joyData.x = x/r; joyData.y = y/r;
};
document.getElementById('joy').ontouchend = () => {
    joyData.x = 0; joyData.y = 0; stick.style.transform = '';
};

let moveUp = 0;
document.getElementById('up').ontouchstart = () => moveUp = 1;
document.getElementById('up').ontouchend = () => moveUp = 0;
document.getElementById('down').ontouchstart = () => moveUp = -1;
document.getElementById('down').ontouchend = () => moveUp = 0;

/* ===== ЦИКЛ ===== */
function animate() {
    const dt = clock.getDelta();
    requestAnimationFrame(animate);

    // Вектор направления взгляда для движения
    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
    forward.y = 0; right.y = 0; forward.normalize(); right.normalize();

    // Движение
    const moveVec = new THREE.Vector3()
        .addScaledVector(forward, -joyData.y)
        .addScaledVector(right, joyData.x)
        .addScaledVector(new THREE.Vector3(0,1,0), moveUp);
    
    player.vel.lerp(moveVec.multiplyScalar(player.speed), 0.1);
    player.pos.addScaledVector(player.vel, dt);
    
    camera.position.copy(player.pos);
    camera.quaternion.setFromEuler(player.rot);

    // Фонарик
    flashlight.position.copy(player.pos);
    const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
    flashlight.target.position.copy(player.pos).add(dir);

    updateChunks();
    renderer.render(scene, camera);

    // UI
    if (Math.random() > 0.9) {
        document.getElementById('fps').textContent = Math.round(1/dt);
        document.getElementById('chunks').textContent = chunks.size;
        document.getElementById('pos').textContent = 
            `${player.pos.x.toFixed(0)}, ${player.pos.y.toFixed(0)}, ${player.pos.z.toFixed(0)}`;
    }
}

window.onresize = () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
};

animate();
</script>
</body>
</html>
